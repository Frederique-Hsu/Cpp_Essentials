/*!
 *  \file       main.cpp
 *  \brief      This project will study the topic of lambda expression in C++.
 *
 */


#include <gtest/gtest.h>

int main(int argc, char* argv[])
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

/*!
 *  \title      lambda expression
 *
 *  \brief      lambda表达式或称lambda函数是定义和使用匿名函数对象的一种简便方式。
 *
 *              一条lambda表达式包含以下组成要件：
 *  \list
 *      \li     一个可能为空的捕获列表 capture list
 *              指明定义环境中的那些名字能被用在lambda表达式内，以及这些名字的访问方式是拷贝还是引用。
 *              捕获列表位于[]内
 *
 *      \li     一个可选的参数列表 parameter list
 *              指明lambda表达式所需的参数，参数列表位于()内
 *
 *      \li     一个可选的mutable修饰符
 *              指明该lambda表达式可能会修改它自身的状态，即：改变通过值捕获的变量的副本
 *
 *      \li     一个可选的noexcept修饰符
 *
 *      \li     一个可选的->形式的返回类型声明
 *
 *      \li     一个表达式体 body
 *              指明要执行的代码，表达式体位于{}内
 *  \endlist
 *
 *  \note       普通函数与lambda函数的区别是：lambda函数具有局部变量“捕获”功能，
 *              而这意味着lambda可以作为局部函数使用。普通函数却不能。
 *
 *              把lambda生成的类的对象称为闭包对象 closure object
 *
 *              lambda是一种局部类类型，它含有一个构造函数以及一个const成员函数operator()(args).
 */


/*!
 *  \section    lambda引入符 []
 *
 *  \list
 *      \li     []: 空捕获列表 - 这意味着在lambda内部无法使用其外层上下文中的任何局部名字。 对于这样的lambda表达式
 *                  来说，其数据需要从实参或者非局部变量中获得。
 *
 *      \li     [&]: 通过引用隐式捕获 - 所有局部名字都能使用，所有局部变量都通过引用访问。
 *
 *      \li     [=]: 通过值隐式捕获 - 所有局部名字都能使用，所有名字都指向局部变量的副本，这些副本是在lambda表达式
 *                   的调用点处获得的。
 *
 *      \li     [捕获列表]: 显式捕获 - 捕获列表是通过值或者引用的方式捕获的局部变量（即：存储在对象中）的名字列表。
 *                         以&为前缀的变量名字通过引用捕获，其他变量通过值捕获。捕获列表中可以出现this, 或者紧跟
 *                         ...的名字以表示元素。
 *
 *      \li     [&, 捕获列表]: 对于名字没有出现在捕获列表中的局部变量，通过引用隐式捕获。捕获列表中可以出现this.
 *                            列出的名字不能以&为前缀。捕获列表中的变量名通过值的方式捕获。
 *
 *      \li     [=, 捕获列表]: 对于名字没有出现在捕获列表中的局部变量，通过值隐式捕获。捕获列表中不允许包含this.
 *                            列出的名字必须以&为前缀。捕获列表中的变量名通过引用的方式捕获。
 *  \endlist
 *
 *  \note       以&为前缀的局部名字总是通过引用捕获。相反地，不以&为前缀的局部名字总是通过值捕获。
 *              只有通过引用的捕获才允许修改调用环境中的变量。
 *
 *              有时候，我们会指定捕获列表(capture-list)，这么做有助于细粒度地管理和控制调用环境中的哪些名字
 *              能被使用以及如何使用。
 *
 *  \details    到底该通过值还是通过引用捕获名字呢？ 选择的依据其实与函数实参完全一致。
 *
 *              - 如果我们希望向捕获的对象写入内容，或者捕获的对象很大，则应该使用&
 *
 *              - 然而对于lambda来说，还应该注意lambda的有效期可能会超过它的调用者。如果发现lambda的生命周期可能
 *                比它的调用者更长，就必须确保所有局部信息都被拷贝到闭包对象中，并且这些值应该通过return机制或者
 *                适当的实参返回。
 *
 *              - 当把lambda传递给其他线程时，一般来说通过值捕获([=])更优，通过引用或指针访问其他线程的栈内容是
 *                一种危险的操作。更严重的是，试图访问一个已终止线程的栈内容会引发极难发现的错误。
 */
