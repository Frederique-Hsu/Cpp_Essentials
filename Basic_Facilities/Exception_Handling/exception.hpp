/*!
 *  \file       exception.hpp
 *  \brief
 *
 */


#pragma once

#include <string>


/*!
 *  \brief      异常是指被程序抛出的一个对象，它表示在程序中出现了一个错误。
 *              异常可以是任意类型的对象，只要它能被拷贝即可。
 *              但强烈建议程序员使用自定义的专门用于表示错误的类型，通过这么做我们可以尽量避免两个完全无关的库使用
 *              同一个值（比如17）表示完全无关的错误，从而减少错误恢复代码陷入混乱的可能。
 */


/*! \section    定义异常的方法
 *              最简单的定义异常的方法就是为一种错误定义一个专门的类，当遇到错误时抛出它。
 *
 *  \note       程序员应该尽一切可能坚持“异常处理是错误处理”的观点。
 *              这样做有助于把代码清晰明确地划分成两部分：普通代码和错误处理代码，从而提高代码的可读性。
 *              此外，C++语言在实现异常机制时对它进行了优化，优化的前提正是明确它的作用是要处理异常。
 */
struct RangeError
{
};

void fn(int n);

struct Tree
{
    std::string str;
    struct Tree* left;
    struct Tree* right;
};

Tree* find(Tree* p, const std::string& s);
void init(Tree* p, const std::string& s);
void deinit(Tree* p);
void insert(Tree* p, const std::string& s);

/*!
 *  \subsection 何时不应使用异常？
 *
 *  \details    异常是唯一一种完全通用的系统化地处理C++程序错误的机制。但也要认识到有的程序出于历史的或者实践的
 *              原因无法使用异常。 例如：
 *
 *  \list
 *      \li     嵌入式系统中的时间关键性组件，我们必须确保该组件的任务在预定的最大时限完成。
 *              因为到目前为止，还没有哪个工具可以准确计算出throw和catch在处理异常时所需的时间上限。
 *              所以我们必须采用其他处理错误的方法。
 *
 *      \li     规模较大的旧系统，他们的资源管理非常混乱（比如用“裸”指针，new和delete杂乱地管理自由存储），没有
 *              采用资源句柄等系统化的管理模式。
 *  \endlist
 *
 *              在这些情况下，我们不得不采用“传统的”（异常之前的）技术处理错误。
 */

/*!
 *  \subsection 异常保障
 *
 *  \details    要想从错误中恢复过来，换句话说，要想捕获异常并继续执行程序，我们必须清楚地指导恢复之前和之后的确切状态。
 *              只有这样，恢复才有意义。
 *
 *  \def        异常安全 exception-safe
 *
 *              如果在通过抛出异常终止某个操作后，程序仍然处于有效状态，则称这个操作是异常安全的操作。
 *
 *  \def        有效状态 (valid state)是指构造函数已经完成且尚未执行析构函数的状态。
 *
 *  \note       一个抛出异常的操作仅仅确保运算对象处于定义良好的状态还不够，它必须是放掉之前申请的全部资源。
 *              例如：在异常抛出点，所有已分配的内存要被是放掉。
 *              谨记内存不是唯一一种可能泄漏的资源。
 *              我们通常把从系统某处申请并且将（显式或者隐式）归还回去的东西统称为资源。
 *              文件、锁、网络连接和线程都是系统资源。
 *              函数在抛出异常前必须是放掉这些资源或者把他们移交给其他资源句柄。
 *
 */
